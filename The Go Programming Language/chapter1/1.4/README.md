# Note

`dup` 取重复这个程序结合 map 的思想很巧妙，复杂度为 O(n)。除了这种算法之外还有其它算法可以实现吗？它们的复杂度是怎样的？
这是我们的问题，也是留给日后实践的。


文件的解析，在 `dup2.go` 中我想通过 `file` 去读取文件到切片。当然这种方式是可行的，但还不够优雅。优雅的方式是将 `file` 传给另外一个对象 `bufio.NewScanner(f)`。由它去做文件的读取，这样做的好处是实现了封装，且复用了 `dup1.go` 中的函数 `countLines`：
```
file, err := os.Open("./file")
countLines(file)
```


有一个实践性的小点是当一段代码被使用到两次及以上时就可以考虑封装它们为函数（或方法）了，这样做的好处是统一了改动，使代码更简洁。  

还有一个实践性的小点是函数中调用内容不同而其它部分一样时，可以考虑将该函数作为闭包传递，详情见 [这里](../1.3/README.md)  


注意 `dup1.go` 是怎么读取 `os.stdin` 的数据的，如果不设 `break` 判断。程序会循环等待读取 `os.stdin` 的流数据。


practice 中 `dup2_update.go` 程序中用到了 flag。当想确认唯一性的时候，flag 往往是最先想到的。


不管是 `os.stdin` 还是 `os.File` 都实现了 `io.Reader` 接口。程序里大量的对象实现了 `io.Reader` 和 `io.Writer`，了解并掌握这部分内容对后续的开发很有必要。先本地更新这其中的接口关系，后续在更新。
